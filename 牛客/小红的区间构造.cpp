#include <iostream>
using namespace std;

int main()
{
    long long n, k, x;
    cin >> n >> k >> x;
    long long l = x * (n - 1) + 1;
    long long r = l + k - 1;
    if (r < 2e9 && (r / x) - ((l - 1) / x) == n)
    {
        cout << l << " " << r << endl;
    }
    else
    {
        l = x;
        r = l + k - 1;
        while ((r / x) - ((l - 1) / x) < n && r < 2e9)
        {
            l += x;
            r = l + k - 1;
        }
        if ((r / x) - ((l - 1) / x) == n && r < 2e9)
        {
            cout << l << " " << r << endl;
        }
        else
        {
            cout << -1 << endl;
        }
    }
    return 0;
}

/*题目描述
小红拿到了正整数 x，她希望你找到一个长度为 k 的区间，满足区间内恰好有 n 个数是 x 的倍数。你能帮帮她吗？
输入描述:
在一行上输入三个整数 n,k,x (1 ≤ n,k,x ≤ 10⁹)。
输出描述:
如果答案不存在，直接输出 -1；否则，输出两个正整数 l,r (1 ≤ l ≤ r < 2 × 10⁹; l + k - 1 = r) 代表答案。
如果存在多个解决方案，你可以输出任意一个，系统会自动判定是否正确。注意，自测运行功能可能因此返回错误结果，请自行检查答案正确性。
示例 1:
输入
2 5 3
输出
6 10
说明
在这个样例中，[6,10] 区间内恰好有 2 个数是 3 的倍数，符合要求。

我们需要找到一个长度为 k 的区间 [l, r]，使得在这个区间内恰好有 n 个数是 x 的倍数。区间的限制是 1 ≤ l ≤ r < 2 × 10⁹。
解决方案步骤
初始尝试：
我们首先尝试从 l = x * (n - 1) + 1 开始。这是因为我们希望在区间内有 n 个 x 的倍数，l 的这个选择可以确保我们从一个合理的起点开始。
计算 r = l + k - 1，这是区间的右边界。
2. 条件检查：
检查区间 [l, r] 中 x 的倍数的个数是否为 n，即 (r / x) - ((l - 1) / x) == n。
同时确保 r 不超过限制 2e9。
3. 备选方案：
如果初始尝试不成功，我们从 l = x 开始，逐步增加 l，每次增加 x，以确保 l 是 x 的倍数。
重新计算 r = l + k - 1，并检查条件。
继续这个过程，直到找到满足条件的区间，或者 r 超过限制。
输出结果：
如果找到满足条件的区间，输出 [l, r]。
如果没有找到，输出 -1。
关键点
倍数计算：(r / x) - ((l - 1) / x) 计算了区间 [l, r] 中 x 的倍数的个数。
循环查找：通过循环调整 l，确保我们能找到一个满足条件的区间。
边界条件：确保 r 不超过 2e9，以满足题目要求。*/