#include <bits/stdc++.h>
using namespace std;

int op(int n, int m){
    while (m-- && n > 1){
        int minVal = 0x77777777;
        if (n >= 0){
            minVal = min(minVal, (int)ceil(sqrt(n)));
        }
        minVal = min(minVal, n - 1);
        minVal = min(minVal, (n - 1) / 2 + 1);
        n = minVal;
    }
    if (m >= 0){
        n -= (m + 1);
    }
    return n;
}

int main(){
    int t;
    cin >> t;
    while (t--){
        int n, m;
        cin >> n >> m;
        cout << op(n, m) << endl;
    }
    return 0;
}
// 题目
/*小娟给阿笙出了一种简单数学题，小娟给出数字 n，并规定三种操作：
若 n 为非负整数，开根号（向上取整），即 n→[√n]；
对当前的数字 n 减 1，即 n→n - 1；
对当前数字除以 2（向上取整），即 n→[n/2]；
现在可以对数字 n 操作 m 次，小娟想让阿笙计算出操作 m 次之后 n 最小可以为多少。
输入描述：
每个测试文件均包含多组测试数据。第一行输入一个整数 T (1≤T≤2×10^6) 代表数据组数，每组测试数据描述如下：
在一行上输入两个整数 n,m (1≤n,m≤10^9) 代表初始数字、操作次数。
输出描述：
对于每一组测试数据，在单独的一行上输出一个整数，代表操作 m 次之后 n 最小可以为多少。
示例 1：
输入：
3
10 1
2 1
2 100
输出：
4
1
-98
说明：
对于第一组测试数据，三种操作得到的答案依次为：10→[√10]=4；10→10 - 1=9；10→[10/2]=5。综上，最小答案为 4。
对于第二组测试数据，三种操作得到的答案依次为：2→[√2]=2；2→2 - 1=1；2→[2/2]=1。综上，最小答案为 1。*/

// 优化思路
/*1. 题目分析
有三种操作：
对非负数开平方根（向上取整）
减1
除以2（向上取整）
目标是在m次操作后得到最小可能值
数据范围：1≤n,m≤10^9，这意味着需要特别注意时间复杂度
2.解题思路演进
第一版（超时）
// 使用BFS尝试所有可能的操作路径
int op(int n, int m) {
    queue<int> q;
    q.push(n);
    while (m--) {
        // 处理当前层所有状态
        // ...
    }
}
问题：
时间复杂度O(3^m)，因为每步都存储了所有可能的状态
空间复杂度O(3^m)，需要存储大量中间状态
对于大的m值完全无法接受
第二版（超时）
// 每步只保留最小值
int op(int n, int m){
    while (m--){
        int minVal = 0x77777777;
        if (n >= 0){
            minVal = min(minVal, (int)ceil(sqrt(n)));
        }
        minVal = min(minVal, n - 1);
        minVal = min(minVal, (n - 1) / 2 + 1);
        n = minVal;
    }
    return n;
}
改进：
不再使用BFS，每步只保留最小值
时间复杂度降为O(m)
空间复杂度降为O(1)
但仍然超时，因为m可能非常大
最终版（AC）
int op(int n, int m){
    while (m-- && n > 1){  // 关键优化点1
        int minVal = 0x77777777;
        if (n >= 0){
            minVal = min(minVal, (int)ceil(sqrt(n)));
        }
        minVal = min(minVal, n - 1);
        minVal = min(minVal, (n - 1) / 2 + 1);
        n = minVal;
    }
    if (m >= 0){          // 关键优化点2
        n -= (m + 1);
    }
    return n;
}
3. 最终版本的关键优化
提前终止条件
while (m-- && n > 1)：当n≤1时停止计算三种操作
原因：当n≤1时，减1操作一定是最优的，不需要再考虑其他操作
剩余操作的快速处理
if (m >= 0) n -= (m + 1)
当n≤1后，剩余的操作次数可以直接用来减1
避免了大量不必要的循环
时间复杂度分析
最坏情况下复杂度为O(log n)
因为n会通过开平方根或除以2快速减小
一旦n≤1，剩余操作直接处理完成
4. 其他优化细节
初始值选择
使用0x77777777而不是INT_MAX作为初始最大值
这是一个足够大的值，同时避免了可能的整数溢出
运算优化
(n-1)/2 + 1代替了向上取整除法
避免了使用ceil函数的额外开销
*/